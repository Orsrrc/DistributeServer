# 分布式流媒体

## 定义

将分布式存储技术应用于流媒体服务业务即分布式流媒体 

- 跟踪服务器：跟踪服务器负责管理所有存储服务器和组。每台存储服务器启动后， 都会与跟踪服务器建立连接，向其通告自己所隶属的组，并保持周期性心跳。跟 踪服务器据此维护组——存储服务器映射表
- 客户机：提供上传、删除等针对存储服务器内容的管理和维护功能
- HTTP服务器：内置的Web Server，支持基于HTTP的流媒体下载和播放
- HTTP客户机：支持HTTP协议的流媒体播放器

- Keepalived：在多台存储服务器和多 台跟踪服务器之间实现热切换

- 组：内容对等的存储服务器集合，其 文件系统通过GlusterFS实时同步– 存储服务器：实际存储流媒体文件的 服务器，同组存储服务器互为备份
- 跟踪服务器集群：由多台跟踪服务器 组成的集群，互为热备，负载均衡

## 服务器

### 单机服务器

![image-20240221145239897](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221145239897.png)

缺点 

服务器压力大 存储空间  用户多了后 不堪重负

Centos ubuntu 等等

改进 

存储模块 放置于别的存储集群 类似NAS的东西

![image-20240221145659932](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221145659932.png)

### 独立服务器

例如 将cpu的时间片调小

![image-20240221150102916](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221150102916.png)

应用服务器 处理与存储无关的功能

上传客户机  对资源服务器进行管理

![image-20240221150319108](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221150319108.png)

交互性越高  时间片越短  I/O速度越快 所需时间片越长

### 分布式存储

分布式 将每个模块独立出去 不单独放置于一台机器

![image-20240221150702303](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221150702303.png)

- 仲裁系统（反向代理，实时监测服务器的存活、最空闲的服务器） 

  - 选中某一存储主机

  - 保证负载均衡

- 容灾系统 
  - 管理多级备份  热切换 主机与备份机实时同步状态 当主机损坏 则交给备份机

![image-20240221151206623](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221151206623.png)

可以不用停机维护

对外部采用http协议进行请求，然后根据协议内容将外部请求转换为内部操作

![image-20240221151306356](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221151306356.png)

## 概要设计

### 系统总体架构

- 客户机 为专用客户端，可用于后台管理

- HTTP服务器主要用于提供外部服务，这样就可以不用对外部用户专门开发一个客户端，只需要提交对应的http请求，请求正确，则可以变成内部请求，发送响应。
- ID服务器
  - 文件、业务的标识
  - 保存文件存储的时候避免文件覆盖，保证路径唯一

![image-20240221152631502](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221152631502.png)

ID服务器 产生ID 保证一个集群中的各个进程ID号等等 唯一

GlusterFs 文件管理系统



### 跟踪服务器

即仲裁系统

- 实时跟踪存储服务器集群的状态

- 每个组间的服务器互为镜像  可以根据业务需求 将各个组放置到不同的地区

![image-20240221153407405](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221153407405.png)

被动接受 存储服务器信息 存储服务器 服务注册

存储服务器 周期发送心跳包  跟踪服务器 周期检查心跳包

### 存储服务器和ID服务器

![image-20240221154050167](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221154050167.png)



### 客户端

![image-20240221154307664](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221154307664.png)



每个业务可能由一个服务器集群完成 当客户端请求某一业务处理时 需要知道对应服务器的信息

那么集群多了以后 客户机所需要维护的信息就回增多 成本增加 所以 可以类似索引一样的处理 将所有的服务器集群的信息 所能够完成的业务交给某一个专用的服务器来完成

客户机只需要与该服务器进行交互 只需要维护一个服务器的信息即可  由该服务器将所需要处理的业务分发出去



### HTTP服务器和客户机

![image-20240221155137571](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221155137571.png)



## 需求分析

### 客户机

#### 上传文件

- 会首先向任意一台跟踪服务器索要可用存储服务器的地址列表
- 跟踪服务器根据客户机提交的用户ID，通过查询数据库确定其所隶属的组，并从 其所维护的数据结构中挑选出若干台该组当前处于活动状态的存储服务器，以地 址列表的形式返回给客户机
- 而后客户机便可从此地址列表中选择一台存储服务器，发起上传文件请求– 后者一方面根据取自ID服务器的唯一标识确定存储路径并保存客户机上传的文件 内容数据，另一方面将客户机提交的文件ID和该文件存储路径的对应关系保存在 数据库中，以备日后下载和删除
- GlusterFS将在稍后的时间里，把此文件同步到组内的其它存储服务器中

#### 下载或删除

- 同样会先向跟踪服务器索要可用存储服务器地址列表，并向其中的一台存储服务 器发起下载或删除请求
- 存储服务器根据客户机提交的文件ID通过查询数据库找到与其对应的文件存储路 径，读取其内容回传客户机或直接将其删除，对于后者还需要同时更新数据库， 以反映存储中所发生的变化
- GlusterFS也同样会把这些变化同步到组内的其它存储服务器中

### HTTP服务器和客户机

- HTTP服务器将客户机的下载功能包装在针对HTTP请求GET方法的处理中， 直接将从存储服务器下载得到的文件内容数据以HTTP响应的形式回传给 HTTP客户机 知 识 讲 解
-  后者可以是简单的wget命令，得到完整的离线媒体文件，也可以是任何支持 HTTP协议的流媒体播放器，以实现在线实时播放

### 存储服务器和ID服务器

- 系统中包括一到多台存储服务器，它们被划分为若干组 
- 每个存储服务器组通过GlusterFS保证其所有组员文件系统的同步性 知 识 讲 解
- 每台存储服务器上的文件保存在特定的目录结构中，其存储路径根据取自ID 服务器的唯一标识计算而得
- 每台存储服务器通过启动时的加入和周期性的心跳，保证其运行状态得以实 时反映于每台跟踪服务器所维护的数据结构中

### 跟踪服务器

-  系统中包括一到多台跟踪服务器，每台跟踪服务器均维护完全相同的数据结 构，以实时跟踪系统中每台存储服务器的状态变化 知 识 讲 解
- 每台存储服务器启动伊始即将自己的详细信息加入到每台跟踪服务器所维护 的数据结构中，并在此后以一定的周期间隔向每台跟踪服务器发出心跳信息， 将自身的状态标记为活动 
- 同时跟踪服务器也以一定的周期间隔检查其所维护的数据结构，将长期收不 到心跳信息的存储服务器标记为离线



## 详细设计

### 报文规约  

![image-20251113142734536](./README.assets/image-20251113142734536.png)

#### 跟踪服务器通信报文

TCP是面向数据流的，这就导致发送的时候是一个TCP包一个TCP包的发送，但是接收的时候不会是一个包一个包的接收，一次可能会接收包的一部分，也有可能会接收一个包多一点的字节流。

因此会有一个**TCP粘包**的问题，即如何去区分边界的问题

- 方法一：包与包之间边界明确 例如每个包之间有一个符号
- 方法二：规定包的结构
  - 定义一个固定长度的包头，TCP接收到字节流了以后，先读包头长度的字节，不够，则下次继续读。从包头中获取到包体长度，然后读取对应的包体内容。

##### 请求加入

存储服务器告诉跟踪服务器，程序启动

- 命令10 代表请求
- 命令100 代表成功

![image-20240221155456940](D:/Admin/Documents/GitHub/DistributeServer/README.assets/image-20240221155456940.png)

定义一个报文 ，TCP是流式结构，根据固定长度的报头 来知晓该包的结构

##### 发送心跳

被动获取存储服务器状态

例如，网络断开时，跟踪服务器长时间未获取到存储服务器的心跳包，就可以判断该存储服务器离线，此时向储存服务器请求信息时不会向该离线的服务器请求信息

![image-20251113142850093](./README.assets/image-20251113142850093.png)

##### 客户机(后台管理)向跟踪服务器获取存储服务器地址列表

**跟踪服务器扮演反向代理**

代理即该服务器不做任何操作，只是单纯的将请求进行转发，该服务器知道应该将该请求发送给哪个服务器进行处理，然后反向代理又将响应发送给客户端

-  正向代理
  - 代理客户端
- 反向代理
  - 代理服务器

![image-20251113142923748](./README.assets/image-20251113142923748.png)

- 这里发送的是存储服务器的地址列表，主要是为了高可用性，避免客户端无法请求某一地址，而没有备选项

##### 客户机获取组列表

- 该报文进行维护 网络拓扑

![image-20251113142957421](./README.assets/image-20251113142957421.png)

#### ID服务器通信报文

通过ID来查询值

即键值对

##### 存储服务器获取ID

![image-20251113143050504](./README.assets/image-20251113143050504.png)

#### 存储服务器通信报文

##### 客户机上传文件

![image-20251113143132970](./README.assets/image-20251113143132970.png)

##### 客户机询问文件大小

- 可以通过应用ID 用户ID 文件ID 进行访问控制
- 当用户不满足某种条件的时候直接返回失败响应即可

![image-20251113143152011](./README.assets/image-20251113143152011.png)

##### 客户机下载文件

偏移和大小代表开始下载文件的位置以及大小

在视频流进行传输的时候，边下载边播放，这样可以保证用户播放客户端的流畅性，当然也可以整体下载，即偏移为0，大小为整个文件。

![image-20251113143206963](./README.assets/image-20251113143206963.png)

##### 客户机要求删除文件

![image-20251113143233363](./README.assets/image-20251113143233363.png)



### 库表设计

![image-20260213174116217](./README.assets/image-20260213174116217.png)

####  跟踪服务器库（tnv_trackerdb ）

- 组信息表 t_groups_info
  - ![image-20260213174231487](./README.assets/image-20260213174231487.png)
- 组路由表 t_router
  - ![image-20260213174255566](./README.assets/image-20260213174255566.png)

#### ID服务器数据库（tnv_idsdb）

- ID生成表 t_id_gen
  - ![image-20260213174424337](./README.assets/image-20260213174424337.png)

- 不同的ID表示标识着不同的硬盘，这样可以进行随机的存储，以分摊风险，例如某一个硬盘损坏，
- id_value 标识着ID生成的区段
  - 例如区段为100，代表这个区段的ID正在被分配，这样避免了当服务器重启时，ID未记录的问题，导致ID重复，也避免了存储每个ID浪费IO空间
- 这里的ID的生成为四个512个数  即一块硬盘可以存储的文件个数为512 ^4^ 
- 生成的规则为每逢512进一

#### 存储服务器库（tnv_storagedb）

- 文件信息表（t_file_xx）
  - 这里的文件路径是来自于ID服务器生成的数据

- ![image-20260213174518640](./README.assets/image-20260213174518640.png)

id 即文件id，上传的文件凭证

之前我们统计了一块硬盘的文件数为512^4^ 这对于数据库来说条目过多，导致检索数据慢，因此采用垂直拆表的方法，即一张表拆成多个小表，这样可以加快检索数据。这需要确认多张表间的联系

还有就是水平拆表

即每张小表的表头是一样的，根据规则将数据存入到不同的小表中。例如，根据哈希算法，并将结果限制在某一个区间内，最终保证每个表的规模是差不多的大小。



增强差异性，从而生成较小概率产生ID

- ![image-20260213174608653](./README.assets/image-20260213174608653.png)

根据ID生成算法，每个客户端可以生成一个ID并且重复概率较低



## 项目结构

### 目录结构

![image-20251113164238021](./README.assets/image-20251113164238021.png)

### 公共模块

![image-20260213194417170](./README.assets/image-20260213194417170.png)

- util 实用函数的声明和定义
- proto 报文相关的宏和数据类型

### 跟踪服务器

![image-20260213194506059](./README.assets/image-20260213194506059.png)

- 缓存类  
  - 减少数据库访问频率
  - 只要执行了相同的执行语句，在数据库不变的情况下，结果相同，那么可以先将查询条件以及查询的结果缓存起来，以减少查询数据库的频率。如果在较短的时间内再次访问，可以从缓存中获取。

- 状态检查线程类
  - 不间断的去检查存储服务器的通讯链接
- 服务器类
  - 套接字等

### ID服务器

![image-20260213194532219](./README.assets/image-20260213194532219.png)

### 存储服务器

![image-20260213194612352](./README.assets/image-20260213194612352.png)

- 跟踪客户机线程类
  - 发送心跳包

### 客户机

![image-20260213194623972](./README.assets/image-20260213194623972.png)

短连接

- 连接的生命周期只持续到接收响应
- 优点：空间上不会浪费空间，因为当连接持续存在的时候，内存资源持续占用
- 缺点：花费大量时间在握手与挥手上
- 牺牲时间换取空间

长连接

- 连接建立上以后不再断开

> 连接池是一个折中的方案，连接建立以后放入到连接池中，在一个时间阈值之内，连接不中断，想要获取连接及时取用即可。而一定的时候以后释放连接，有新的连接请求时再建立连接
>
> 连接类做成套接字的封装，即通讯句柄，通过连接池管理器中获取到句柄，进行通讯。

将客户端封装成一个接口库.a，这样用户需要使用二次开发的时候，直接调库即可，即想下载和上传调用API即可。

### HTTP服务器

web服务器

接口的转发

![image-20260213194638241](./README.assets/image-20260213194638241.png)